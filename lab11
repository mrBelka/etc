{Дана строка, содержащая русский текст. Если в тексте есть слово-палиндром длиной более 1-й буквы, то вывести слова текста в соответствии с убыванием количества звонких согласных, в противном случае удалить из слов текста гласные буквы и вывести полученные слова в алфавитном поpядке. ( Звонкие согласные: бвгжздйлмнр )}

{$APPTYPE CONSOLE}
{$R+,Q+}

uses
  SysUtils;

const letter=['а'..'п','р'..'я','А'..'Я'];
      zvonk=['б','в','г','ж','з','д','й','л','м','н','р'];
      glas=['а','о','е','ё','у','ю','ы','э','я','и'];

var
  t,w:string;
  i,j,k,n,l,flag,f:integer;
  slovo:array[1..1000] of string;
  a:array [1..1000] of integer;

begin
  assign(input,'input.txt');
  reset(input);
  assign(output,'output.txt');
  rewrite(output);

  //считываем строку и разделяем ее на слова
  readln(t);
  t:=t+'.';
  i:=1;
  while i<=length(t) do begin
      //t[i] - это буква, несмотря на то, что t - строка!!!
      //по сути строка - это массив букв, поэтому доступ к конкретной букве осуществляется по ее порядковому номеру, начиная с 1 : t[номер в строке]
      if t[i] in letter then begin
        w:='';
        while t[i] in letter do begin
            w:=w+t[i];
            inc(i);
        end;
        inc(n);
        slovo[n]:=w;
      end
      else inc(i);
  end;

  //определим, является ли хотя бы одно слово палиндромом
  //первоначально палиндрома нет
  flag:=0;
  //запустим цикл по всем словам с 1 по n
  for j:=1 to n do begin
      //если длина слова меньше 2 символов - то слово не палиндром, берем следующее
      if length(slovo[j])<2 then continue;
      //если длина 2 или больше символа, то копируем слово из массива в новую строку
      t:=slovo[j];
      //определяем флаг=0
      f:=0;
      //определяем l = длина строки
      l:=length(t);
      //начинаем проверять буквы слова
      //будем брать первую и последнюю буквы, затем вторую и предпоследнюю, и т.д.
      //нам достаточно идти только до половины слова, если кол-во символов в нем четное
      //так же до половины идем, если кол-во символов в слове нечетно, вернее не до половины, а до n div 2 элемента
      //потому что средняя буква не учитывается: слово из 5 букв - 1 и 5, 2 и 4, а 3-средняя
      for i:=1 to l div 2 do begin
          //если хотя бы одна пара букв неодинакова, то отражаем этот момент в флаге и выходим из цикла
          if t[i]<>t[l-i+1] then begin
            f:=1;
            break;
          end;
      end;

      //если флаг=1, т.е. слово, которое мы брали - не полиндром, то берем следующее слово
      if f=1 then continue;

      //а если взятое нами слово палиндром, то отражаем это во флаге и...
      flag:=1;
      //...выходим из цикла, тк дальше проверять нет смысла
      break;
  end;

  //если не встретили ни одного палиндрома
  if flag=0 then begin
      //считаем кол-во звонких согласных в слове, для этого используем массив a[], индексы которого от 1..1000 - т.е. a[1] - кол-во звонких согл. первого слова и т.д
      //запускаем цикл по всем словам с 1 по n
      for j:=1 to n do begin
          //записываем слово в новую строку
          t:=slovo[j];
          //обнуляем счетчик количества звонких согл. в слове
          a[j]:=0;
          //запускаем цикл от первой буквы до последней, length(t) - длина слова, но и номер последней буквы,
          for i:=1 to length(t) do
              //если буква является звонкой, то увеличиваем счетчик
              if t[i] in zvonk then a[j]:=a[j]+1;
      end;

      //сортируем слова по кол-ву звонких согл.
      //обычная сортировка обменами, сортируем массив a[]
      for j:=1 to n-1 do
          for i:=j+1 to n do
              if a[i]<a[j] then begin
                 //только помним, что к массиву а[] нами на словах привязан массив слов, следовательно
                 //вместе с элементами массива а нужно менять и соответствующие им слова
                 t:=slovo[j];
                 slovo[j]:=slovo[i];
                 slovo[i]:=t;
                 k:=a[j];
                 a[j]:=a[i];
                 a[i]:=k;
              end;
  end
  //все, на этом мы первый случай отработали

  //если встретили палиндром
  else begin
      //запускаем цикл по всем словам от 1 до n
      for j:=1 to n do begin
          t:=slovo[j];
          //идем циклом по всем буквам слова
          i:=1;
          while i<=length(t) do begin
              //если буква гласная, то
              if t[i] in glas then begin
                //удаляем ее. Процедура Delete удаляем из строки t нескорлько символов начиная с некоторой позиции
                //delete(строка откуда удалить, позиция с которой удалить, сколько символов начиная с этой позиции удалить);
                delete(t,pos(t[i],t),1);
                //берем следующую букву, не увеличивая i. это связано с тем, что при удалении строка смещается на количество удаленных
                //символов. например "Вася". i=2 t[i]='a'. удалим, получим "Вся". но теперь на то надо "c" проверить. а "с" - второй символ i=2
                continue;
              end;
              //если это не гласная, то просто берем след. букву
              i:=i+1;
          end;
          //вернем измененное слово обратно в слов массив,
          //вообще в строку t мы копировали слово потому, что с так удобнее работать. можно было получить букву slovo[j][i] - но это просто не удобно
          slovo[j]:=t;
      end;

      //сортируем слова в алфавитном порядке
      //обычная сортировка обменами
      for j:=1 to n-1 do
          for i:=j+1 to n do
              //слова сравниваются как цифры, потому что на самом деле сравниваются не слова, а их ASCI коды. Сначала сравниваются коды первых букв,
              //потом вторых, и т.д. В ASCI таблице сначала идут символы А-Я, потом а-я, поэтому и нужен ansilowercase (или ansiuppercase), т.е. все буквы
              //переводим в один регистр, и сравниваем их в одном регистре (так a стоит раньше р, вернее ее код в АСКИ меньше, но Я строит также раньше p, а это неправильно)
              //заметь еще, что слова мы не перезаписываем, т.е. сравниваем приводя к одному регистру, но в массиве они как были, так и остануться, это хорошо, потому что
              //исходный текст мы менять не можем
              if AnsiUpperCase(slovo[i])<AnsiUpperCase(slovo[j]) then begin
                t:=slovo[j];
                slovo[j]:=slovo[i];
                slovo[i]:=t;
              end;
  end;

  for j:=1 to n do writeln(slovo[j]);


end.
 
